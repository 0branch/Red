Red/System Language Specifications (working draft)

	Author: Nenad Rakocevic
	Date: 05/05/2011
	Revision: 7
	Status: working draft
	Home: <a href="http://www.red-lang.org">red-lang.org</a>

===Abstract

Red/System is a dialect (<a href="http://fr.wikipedia.org/wiki/Domain-specific_programming_language" target="_new">DSL</a>) of the Red programming language. Its purpose is to provide:

*low-level system programming capabilities

*a tool to build Red's runtime low-level library

*a tool to link code and produce executables

Red/System can be seen as a C-level language with memory pointer support and a very basic and limited set of datatypes.

<u>Implementation note</u>: It is currently provided with a complete tool-chain generating executables from source files. This is a temporary state as Red/System will live inside Red, so will be embedded in Red scripts.

===Syntax

The syntax is almost the same as the one used by REBOL language, as the lexer (<a href="http://www.rebol.com/docs/words/wload.html" target="_new">LOAD</a>) is currently provided by REBOL during the bootstrapping phase. The REBOL syntax doesn't have a formal specification nor an exhaustive documentation, just a superficial description, but it is enough to work with. See:

*<a href="http://www.rebol.com/docs/core23/rebolcore-3.html" target="_new">http://www.rebol.com/docs/core23/rebolcore-3.html</a> (There is a typo in the table, all literals are missing a caret (^) character after the first quote)

*<a href="http://www.rebol.com/r3/docs/guide/code-syntax.html" target="_new">http://www.rebol.com/r3/docs/guide/code-syntax.html</a>

A complete syntax specification for both Red and Red/System will be provided during the implementation of the Red language layer.

For now, Red/System uses 8-bit character encoding (ASCII). Once proper Unicode support will be provided by the Red language layer, Red/System will switch to UTF-8 source encoding.

---Comments

 ;this is a commented line

 print "hello world"    ; this is another comment

 comment {
     This is a
     multiline
     comment
 }

===Variables

Variables are labels used to represent a memory location. The labels (called <b>identifiers</b> from now) are formed by sequences of printable characters without any blank (space, newlines or tabulation). Printable characters are defined as any one-byte character in the 20h-7Eh range that can be printed out in system's console excepting the following ones (used as delimiters or reserved for some datatypes literals): 

 [ ] { } " ( ) / @ # $ % ^ , : ;
    
There is a restriction on the first character, the following characters are forbidden in the first position, but allowed at other positions:

 0 1 2 3 4 5 6 7 8 9
 
Also there is a another restriction to avoid letting the compiler mistake a hex integer with a variable name. Variable name starting with A-F letters consisting of A-F and 0-9 characters and ending with h are not allowed.
 
All identifiers (variables and function names) are <u>case-insensitive</u>.

---Setting a value

Variables can hold any value of the available datatypes. This can be the real value (like integer! or pointer!) or a reference to the real value as is the case for struct! or c-string!). To assign a value to a variable, use a colon character at the end of the variable identifier.

 foo: 123
 bar: "hello"

\note Multiple assignments
Multiple assignments, like a: b: 123, are not supported in Red/System. Such feature could be added in the future if required.

/note

---Getting a value

Just use the variable without any decoration to get its value or to pass it as a function's argument.

 bar: "hello"
 print bar

will output:
 hello
 
---Variable's type

Variables do have a type. Variables do not need to be declared before being used, but they require to be <u>initialized</u> anyway. Functions local variables require to be declared, but the type specification part can be skipped if the variable is properly initialized. For example:

 foo: 123
 bar: "hello"
 size: length? bar
 id: GetProcessID						;-- 'GetProcessID would return an integer!

 compute: func [
 	a [integer!]
 	return: [integer!]
 	/local c							;-- 'c is declared without a type
 ][
 	c: 1								;-- inferred type is integer!
 	a + c
 ]
 
are valid variable usages.

Allowed types are:

*integer!

*byte!

*logic!

*c-string!

*struct!

*pointer!


===Datatypes

---Integer!

+++Literal format

 decimal form          :  1234

 decimal negative form : -1234

 hexadecimal form      :  4D2h

Integer datatype represents natural and negative natural numbers. The memory size of an integer is 32 bits, so the range of supported numbers is : 

 -2147483648 to 2147483647

<b>Hexadecimal format</b>

Hexadecimal integer representation is mostly used to represent memory addresses or binary data for boolean operations. As for character, all hexadecimal literals found in sources are converted to their integer decimal value during lexical analysis. Allowed range is:
    
 00000000h to FFFFFFFFh
 
Hex letters have to be written in <b>uppercase</b>!

\note Hex literal form design decision
The 0x prefix is often used to mark a literal hexadecimal value. It could have been used in Red/System too if the &lt;number&gt;x&lt;number&gt; literal form wasn't reserved in Red for the pair! datatype. As Red/System is a dialect of Red, it has to use the same representation for hex values, so <b>&lt;hexa&gt;h</b> was chosen instead.

/note

---Byte!

Byte! datatype purpose is to represent unsigned integers in the 0-255 range. Byte! is an alias name for the internal uint8! datatype, both will be accepted, but byte! is the official one. 

+++Syntax
	
 #"<character>"
 #"^<character>"
 #"^(hexadecimal)"
 #"^(name)"
 
Examples:

 #"a"
 #"A"
 #"5"
 #"^A"
 #"^(1A)"
 #"^(back)"
 
See <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1" target="_new">http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1</a> for a more complete description of this format.

+++Casting

Casting is allowed to some extent (see section "4.7 Type Casting").

 foo: as integer! #"a"					;-- foo holds 97

 bar: as byte! foo						;-- bar holds #"a"
 
<u>Note</u>: trying to cast an integer value greater than 255 to a byte! will result in a data loss or data corruption. <i>(The handling of this case might be changed in future revisions)</i>

---Logic!

Logic! datatype represents boolean values: <b>TRUE</b> and <b>FALSE</b>. Logic variables are initialized using a literal logic value or the result of a conditional expression. 

As a first class datatype, you can pass logic values and variables as function's argument or use them as function's return value.

+++Literal format

 true
 false

Using a literal to initialize a logic variable:

 foo: true
 either foo [print "true"][print "false"]
 
will output:

 true
 
Using a conditional expression to initialize a logic variable:

 bar: 2 > 5
 either bar [print "true"][print "false"]
 
will output:

 false

---C-string!

A c-string! value is a sequence of not-null bytes terminated by a null byte. A c-string variable holds the memory address of the first byte of the c-string, so it can be viewed as an implicit pointer to byte!. A c-string having a null character as first byte is an empty c-string.

+++Syntax

Literal c-strings are defined using double quotes delimiters or a pair of matching curly braces:

 foo: "I am a c-string"
 bar: {I am
   a multiline
   c-string
 }

\note C-string null byte ending
You don't have to add a null byte to literal c-strings, it is added automatically during compilation.

/note

+++C-string length

It is possible to retrieve the number of bytes (<b>excluding the null</b> end marker) in a c-string at runtime using the LENGTH? function:

 a: length? "Hello"						;-- here length? will return 5
 
\note Length? vs Size?
Do not confuse the LENGTH? function with the SIZE? function (see ...)

/note

+++C-string arithmetic

It is possible to apply some simple math operations on c-string variables like additions and subtractions. C-string address would be increased or decreased by the integer argument.

Syntax

 <c-string> + <n>
 <c-string> - <n>

 <c-string> : c-string variable
 <n>        : integer value

Example

 s: "hello"								;-- let suppose s = 4000000h

 s: s + 1								;-- now s = 40000001h
 s: s + 1								;-- now s = 40000002h	

+++Accessing bytes

It is possible to access individual bytes in a c-string using path notations:

 <c-string>/integer!					;-- literal integer index provided
 <c-string>/<index>						;-- index provided by a variable

 <c-string> : a c-string variable
 <index>    : an integer variable
 
The returned value will be a of <b>byte!</b> type.

Examples:

 foo: "I am a c-string"
 foo/1  =>  #"I"						;-- byte! value (73)
 foo/2  =>  #" "						;-- byte! value (32)
 ...
 foo/15 => #"g"							;-- byte! value (103)
 foo/16 => #"^(00)"						;-- byte! value (0) (end marker)
 
\note Important notes

*In contrary to the C language, indexes in Red/System are <b>one-based</b>.

*The behaviour of path with an index out of bounds is not yet defined. (It is better to avoid it)

/note

Example of a variable used as index:

 c: 4
 foo/c  => #"m"							;-- byte! value (109)

A simple way to traverse a c-string would be:

 foo: "I am a c-string"
 bar: foo

 until [
 	prin form bar/c						;-- form would convert a byte! to a c-string
 	bar: bar + 1
 	zero? bar/c
 ]
 
will output:
 I am a c-string

Similary, it is also possible to write bytes using path notation with an ending colon:

 <c-string>/integer!:	<value>			;-- literal integer index provided
 <c-string>/<index>:	<value>			;-- index provided by a variable

 <c-string> : a c-string variable
 <index>    : an integer variable
 <value>    : a byte! value

For example:

 foo: "I am a c-string"
 foo/3: #"-"
 c: 4
 foo/c: #"-"
 print foo
 
will output
 I -- a c-string
 
---Struct!

Struct! datatype is roughly equivalent to C struct type. It is a record of one or several values, each value having its own datatype. A struct variable holds the memory address of a struct value. 

<u>Implementation note</u>: Struct! values are <u>padded</u> (at tail) in memory in order to preserve optimal alignment for each target (for example, it is aligned to 4 bytes for IA32 target). SIZE? function will return the size of the struct! value in memory without the eventual tail padding.

+++Declaration

Declaring a struct! value is achieved by using the STRUCT keyword followed by a specification block. That block defines struct! value members using pairs of name and datatype definition.

 struct [
 	<member> [<datatype>]
 	...
 ]
 
 <member>   : a valid identifier
 <datatype> : integer! | byte! | pointer! [integer!] |
              c-string! | struct! [<members>]
              
The returned value of STRUCT is the memory address of the newly created struct value.

+++Usage

 s: struct [
 	a 	[integer!]
 	b	[c-string!]
 	c 	[struct! [d [integer!]]]
 ]
 
In this example, the struct value has 3 members: a, b, c, each with a different datatype. The c member is also a struct! value pointer.

+++Accessing members

Member access is achieved using path notation. Syntax is:

 <struct>/<member>						;-- read access
 <struct>/<member>: <value>				;-- write access

 <struct>  : a valid struct variable
 <member>  : a valid member identifier in <struct>
 <value>   : a value of same datatype as <member>


From last example, that would give:

 foo: s/a								;-- reading member 'a in struct 's
 s/a: 123								;-- writing 123 in member 'a in struct 's
 s/b: "hello"
 bar: s/c/d								;-- deep read/write access is also possible
 
+++Struct arithmetic

It is possible to apply some simple math operations on struct variables like additions and subtractions. Struct address would be increased or decreased by the size of the pointed struct value multiplied by the integer argument.

Syntax

 <struct> + <n>
 <struct> - <n>

 <struct>	: struct variable
 <n>        : integer value

Examples

 p: struct [							;-- let suppose p = 4000000h
	a [integer!]
	b [pointer! [integer!]]
 ]										;-- struct memory size would be 8 bytes
 p: p + 1								;-- now p = 40000008h

<u>Note</u>: The struct value size is target and alignment dependent. In the above example, it is supposed to run a 32-bit system with a struct alignment to 4 bytes.

+++Aliases

Struct! values definitions tend to be quite long, so in some cases, when struct! definitions are required to be inserted in other struct! definitions or in functions specification block, it is possible to use an alias name to reference a struct! definition through the source code. It also allows to solve the self-referencing case quite simply.

<u>Note</u>: remember that an alias is not a value, it doesn't take any space in memory, it can be seen as a <i>virtual datatype</i>. So, by convention, alias names should end with a exclamation mark, in order to distinguish them more easily from variables in the source code.

Aliasing syntax:

 <name>: alias struct! [
 	<member> [<datatype>]
 	...
 ]
 
 <name>     : the name to use as alias
 <member>   : a valid identifier
 <datatype> : integer! | byte! | pointer! [integer!] |
              c-string! | struct! [<members>]
              
Struct value declaration using an aliased definition:

 <variable>: struct <alias>

 <variable>  : a struct variable
 <alias>     : a previously declared alias name
 
Struct usage example:

 book!: alias struct! [					;-- defines a new aliased type
 	title		[c-string!]
 	author	 	[c-string!]
 	year		[integer!]
 	last-book 	[book!]					;-- self-referenced definition
 ]

 gift: struct [
 	first  [book!]
 	second [book!]
 ]
 b: gift/first

 b/title:  "Contact"
 b/author: "Carl Sagan"
 b/year:   1985

---Pointer!

Pointer datatype purpose is to hold the memory address of another value. A pointer value is defined by the pointed value address and datatype. As c-string! and struct! are already implicit pointers, so the only pointed datatype allowed is integer! (byte! pointer is already covered by c-string! and logic! pointer is not needed).

<u>Implementation note</u>: The memory size of a pointer is 4 bytes on 32-bit systems (and 8 bytes on 64-bit systems).

+++Literal format

New pointers value can be created using the following syntax:

 pointer [<datatype>]

 <datatype>: integer!

\note Possible syntactic sugar
The & symbol used in previous revisions of this document has been removed due to the new limited pointer! datatype usage. It could be reintroduced again in the future if required.

/note

Examples:

 foo: pointer [integer!]				;-- equivalent to C's: int *foo;

\note Pointer value initialization
Do not assume any default value for a pointer value until it is initialized properly. In the current implementation, global pointer variables are set to 0 by default while local pointer variables default value is undefined. This might change in the future to adopt a default value more suitable for debugging (like 0BADBAD0h or similar hex trick).
 
/note

+++Declaration

Pointer declaration is only required for local pointer variables in functions' specification block. In such case, the datatype declaration can be omitted and left to the inferencer to guess. (See "Type inference" section)

 pointer! [<datatype>]

 <datatype>: integer!

Global variables declaration examples (with C equivalents):

 p: pointer [integer!]							;-- int *p;

Same with local variables declaration examples (with C equivalents):

 func [/local p [pointer! [integer!]]			;-- int *p;

Example of inferred pointer variable type:

 foo: func [
 	a [struct! [count [integer!]]]
 	/local
 		p [pointer! [integer!]]				;-- explicit declaration
 ][
 	foobar p								;-- foobar modifies p
 	a/count: p/value
 ]

 bar: func [
 	a [struct! [count [integer!]]]
 	/local p								;-- p datatype inferred
 ][
 	p: pointer [integer!]					;-- p initialized (implicit declaration)
 	foobar p
 	a/count: p/value
 ]

 bar2: func [
  	a [struct! [count [integer!]]]
  	/local p								;-- p datatype inferred
 ][
  	p: GetPointer a							;-- datatype is guessed from return value
  	foobar p
  	a/count: p/count
 ]

+++Dereferencing

Dereferencing a pointer is the operation allowing to access the pointed value. In Red/System, it is achieved by adding a <b>/value</b> refinement to the pointer variable (called more generally "path notation"):

 <pointer>/value						;-- read access
 <pointer>/value: <value>				;-- write access

 <pointer> : pointer variable
 <value>   : a value of same type as in pointer's definition

Usage example

 p:   pointer [integer!]				;-- declare a pointer on an integer
 bar: pointer [integer!]				;-- declare another pointer on an integer

 p: as [pointer! [integer!]] 40000000h
 p/value: 1234 							;-- write 1234 at address 40000000h
 foo: p/value							;-- read pointed value back
 bar: p									;-- assign pointer address to 'bar
 
<u>Note</u>: Remember that a pointed value is undefined (can contain an arbitrary value) until you define it explicitly  

+++Pointer arithmetic

It is possible to apply some simple math operations on pointer like additions and subtractions (as in C). Pointer address would be increased or decreased by the memory size of the pointed value multiplied by the amount to respectively add or subtract.

 p: pointer [integer!]					;-- pointed value memory size is 4 bytes

 p: as [pointer! [integer!]] 4000000h
 p: p + 1								;-- p points now to 40000004h
 p: p + 1								;-- p points now to 40000008h

+++Pointer path notation

It is possible to use path notation to simulate an array with indexed access. Both reading and writing are possible.

<b>Syntax</b>

 <pointer>/<integer>					;-- literal integer index provided
 <pointer>/<index>						;-- index provided by a variable

 <pointer>  : a pointer variable
 <integer>  : an integer literal value
 <index>    : an integer variable

Examples:

 p: pointer [integer!]

 p: as [pointer! [integer!]] 4000000h
 a: p/1									;-- reads an integer! at 40000000h
 p/2: a									;-- writes the integer! at 40000004h
 
Integer variable can also be used as index:

 p: pointer [integer!]

 p: as [pointer! [integer!]] 4000000h
 c: 2
 p/c: 1234								;-- writes 123 (4 bytes) at 40000008h
 
<u>Note</u>: Pointer's <b>/value</b> notation is strictly equivalent to <b>/1</b>. The <b>/value</b> can be considered as syntactic sugar.

+++Void pointer

There is no specific support in Red/System for C-like void pointers. The official way is to use the integer! type to represent C void* pointers.

For pointers on c-string! or struct! variables, a pointer variable can be used then dereferenced and casted to the target type.

Example:

 p-buffer!: alias struct! [buffer [c-string!]]

 get-hello: function [
 	s [p-buffer]
 	return: [p-buffer]				;-- returns a pointer to a c-string
 ][
 	s/buffer: "hello"
 	s								;-- equivalent to C's char **
 ]
 
 foo: func [
 	/local
 		c [pointer! [integer!]]
 		s [c-string!]
 ][
 	c: get-hello
 	s: as c-string! c/value
 	prin s
 ]
would print
 hello
    

---Type Casting

Type casting is possible between value of compatible types. Compatible types are defined as types which values memory size is equal. Casting is achieved using the <b>AS</b> keyword followed by the target type and the value to cast.

<u>Note</u>: Trying to assign a value to a variable of incompatible type will result in a compilation error. The same action with a compatible type will trigger a compilation warning, asking to add explicit casting or fix the issue if casting was not intended.

Syntax:

 as <new-type> value

 <new-type> : integer! | byte! | pointer! [integer!] |
              c-string! | struct! [<members>]

Example:

 foo: 0									;-- foo is an integer
 bar: pointer [integer!]				;-- bar is a pointer

 foo: as integer! bar					;-- type casting
 bar: as [pointer! [integer!]] foo		;-- complex type is passed as a block
 
---Type Conversion

<i>TBD</i>

===Expressions

<i>TBD</i>

===Functions

Function definition and usage is pretty straightforward in Red/System. The function specification block contains all the definitions required by the function. This includes:

*calling arguments

*optional returned value type

*local variables

*special attributes

---Declaration

<b>Syntax</b>

 <name>: func | function [
 	[<attributes>]						;-- optional part
 	<argument> [<datatype>]
 	...
 	return: [<datatype>]				;-- returned value type (optional part)
 	/local								;-- local variables (optional part)
 	<local> [<datatype>]
 	...
 ][
 	<body>
 ]

 <name>		  : function's name
 <attributes> : special attributes
 <argument>	  : function's argument indentifier
 <datatype>	  : integer! | byte! | logic! | pointer! [integer!] |
                c-string! | struct! [<members>]
 <local>	  : local variable
 <body>		  : function's body code

<b>Examples</b>

 hello: func [][print "hello"]			;-- no arguments, no locals, no return value

 why?: func [return: [integer!]][42]	;-- minimal function returning an integer

 inc: func [							;-- increment an integer
 	a 		[integer!]
 	return: [integer!]
 ][
 	a + 1								;-- last value is returned
 ]

 percent?: func [						;-- return relative percentage of a / b
 	a [integer!]
 	b [integer!]
 	return: [integer!]
 	/local								;-- declare local variables
 	c [integer!]
 ][
 	c: 100
 	a * c / b
 ]
 
---Return value

Any function is able to return a value if necessary. This is trivially achieved as last expression in function's body will be automatically returned if:

*a RETURN: statement is present in function's spec block

*last expression datatype matches the one declared after the RETURN: statement

---Attributes

It is possible to change how the function will behave at runtime using special attributes. 

+++Infix

Allow the function to be called using an infix syntax. The function must take two arguments exactly or else a compilation error will be raised. Example:

 avg: func [[infix] a [integer!] b [integer!] return: [integer!]][
 	(a + b) / 2
 ]

 10 avg 6
will return:
 8
 
<u>Note</u>: When the <b>infix</b> syntax is used, the postfix syntax is still allowed, but it will work only if there is no value on the left side of the function call. Example:

 func [][avg 10 6]						;-- will return 8 as well

 print "ok" avg 10 6					;-- will produce a compilation error

---Type inference

Functions offer a limited type inference possibility for:

*local variables

*return value

In practice, it means that it is allowed to omit a local variable type declaration as long as the variable is initialized properly. Same possibility is offered for return values as long as the compiler can guess without any ambiguity the return value type.

Example:

 foo: func [
 	a [integer!]
 	return:								;-- omitted return value type
 	/local c							;-- omitted local variable type
 ][
 	c: 10								;-- variable type is integer!
 	a + c								;-- return type is obviously integer!
 ]

---Calling a function

Calling a function is achieved by writing its name followed by the required number of arguments.

<i>(from the previous examples)</i>
 hello									;-- will print "hello" in the standard output

 answer: why?							;-- will return 42 in variable 'answer

 foo: 4
 foo: inc foo							;-- foo holds 5 after the call to 'inc

 bar: percent? 3 4						;-- bar holds 75
 
It is also possible to pipe several function calls together:

 foo: percent? 11 inc inc why?			;-- will return 25 in foo
 
 
---Function pointer

It is possible to obtain a function address to pass it, for example, as argument to external calls with callbacks.

<b>Syntax</b>

 :<function name>
 
Example:

 progress: func [count [integer!]][
 	prin "."							;-- make the user see some progress
 ]

 get-file "bigfile.avi" :progress		;-- blocking job would call 'progress
                                        ;-- periodically
                                        
<u>Note</u>: Function address is curently returned as an integer! value but this could be changed in the future to a function pointer!.

---Premature exiting

Exiting at function's end is not always desirable. Sometimes, conditional premature exiting from the function is required. This can be done using EXIT or RETURN special keywords.

+++Exit

Quits immediatly the function.

 test: func [a [integer!]][
 	if zero? a [exit]					;-- exit the function here if a = 0
 	...									;-- if a <> 0, continue processing...
 ]
 
+++Return
 
Quits immediatly the function and returns a value.

 test: func [
 	a [integer!]
 	return: [c-string!]
 ][
 	if zero? a [
 		return "Not allowed"			;-- exit the function here if a = 0
 	]
 	"ok"								;-- return "ok" if a <> 0
 ]

---Nested functions

<i>TBD</i>

===Scoping

In Red/System, variables are statically scoped. The place in source code where a variable is declared determines its scope. 

---Global Context

Global context is defined as the global namespace where all global variables and functions are defined. This context is unique. As a simple rule, every variable not declared in a function is a global variable bound to global context.

Example:

 foo: 123								;-- global variable

 f: func [/local bar [integer!]][
 	bar: 123							;-- locally scoped variable
 ]

---Functions Contexts

Each defined function has its own local context. Variables declared in function's definition block are locally scoped and can't be accessed outside of the function's body. On the other hand, global variable can be referenced and modified from functions. If a local variable has the same name as a global one, the local one will take precedence in function's body. The value of the homonym global variable won't be affected by local redefinitions in functions contexts.

Example:

 foo: 1									;-- global variable
 var: 2

 f: func [
 	return:    [integer!]
 	/local 
 		bar [integer!]
 ][
 	bar: 3
 	foo + var + bar						;-- will return 6
 ]

 f: func [
 	return:    [integer!]
 	/local 
 		bar [integer!]
 		var [integer!]
 ][
 	bar: 3
 	var: 10								;-- 'var is a local variable here
 	foo + var + bar						;-- will return 14
 ]



===Compiler directives

Some features of Red/System need to be processed at compile-time rather than at runtime. This is especially true for features related to the linking phase that builds the executable file. In order to distinguish such compile-time commands or options, compiler directive are introduced. Their syntax is:

 #<directive> <argument-1> <argument-2> ...

 <directive>  : a valid identifier
 <argument-*> : argument can be any Red valid datatype
 
The number of argument is specific to each compiler directive.
 
<u>Implementation note</u>: Directives arguments datatype set is the one provided by REBOL during the bootstrapping phase only. Once the Red layer will be implemented, the allowed datatypes will be Red ones.


===Importing External Libraries

---#import

Red/System is able to dynamically load external shared libraries when a Red/System executable is loaded by the operating system. This requires that the programmer gives instructions to the compiler about which library to load and how to map library's functions to Red/System global context. This feature is called "library import" in Red/System and it is supported by a specific compiler directive: <b>#import</b>. This directive can be used anywhere in the global context of your Red/System program, but pay attention to put it <i>before</i> you use one of the mapped functions, else a compiler error will be raised. This directive can be used multiple times in your source code if it makes it more readable. If there is a huge number of functions to imports, putting them in separate includes files would be considered as a good practice.

<u>Note</u>: this is not the same as dynamically loading a shared library from your Red/System code after your program has started. Such approach allows you to delay the loading of your libraries and to free them. Imports cannot be freed.

<b>Syntax</b>

 #import [
 	"<library>" <convention> [
 		<function name>: "<ID>" [
 			<argument> [<datatype>]
 			...
 			return: [<datatype>]		;-- optional part
 		]
 		...								;-- more functions mappings
 	]
 	...									;-- more libraries to load					
 ]

 <library>		 : shared library file name (with extension)
 <convention>	 : calling convention of the library (stdcall | cdecl)
 <function name> : name of the mapped function in global context
 <ID>			 : identifier of the function in the shared library
 <argument>		 : function's argument indentifier
 <datatype>		 : integer! | byte! | pointer! [integer!] |
             	   c-string! | struct! [<members>]

The <b>RETURN:</b> statement indicates that the mapped function has a return value.

There's no limitation on the number of libraries or functions that can be declared this way.

Supported calling conventions are:

*<a href="http://en.wikipedia.org/wiki/X86_calling_conventions#stdcall" target="_new">stdcall</a>: used mostly by Windows API (but can be also used by third-party DLLs)

*<a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl" target="_new">cdecl</a>: default calling convention used by C shared libraries.

<b>Usage</b>

The following example is Windows-specific. 

 #import [
 	"kernel32.dll" stdcall [
 		process-id?: "GetCurrentProcessId" [
 			return: [integer!]
 		]
 		get-env: "GetEnvironmentVariableA" [
 			name 	[c-string!]
 			buffer	[c-string!]
 			size	[integer!]
 			return: [integer!]
 		]
 	]
 	"msvcrt.dll" stdcall [
 		malloc: "malloc" [
 			size 	[integer!]
 			return: [c-string!]
 		]
 		free: "free" [
 			block	[c-string!]
 		]
 	]
 ]

 pid: process-id?

 max-size: 128
 buf: malloc  max-size						;-- allocate space for 127 characters

 get-env "windir" buf  max-size

 print buf
 free buf
 
would output:

 C:\Windows


---#syscall

As Red/System is destined to be used mostly for low-level system programming, <a href="http://en.wikipedia.org/wiki/System_call" target="_new">syscalls</a> mappings are also supported using the <b>#syscall</b> compiler directive.

<b>Syntax</b>

 #syscall [
 	<function name>: <ID> [
  		<argument> [<datatype>]
		...
		return: [<datatype>]		;-- optional part
	]
	...								;-- more functions mappings
 ]
 
  <function name> : name of the mapped function in global context
  <ID>			  : syscall integer ID
  <argument>	  : syscall's argument indentifier
  <datatype>	  : integer! | byte! | pointer! [integer!] |
             		c-string! | struct! [<members>]

The <b>RETURN:</b> statement indicates that the mapped syscall has a return value.

There's no limitation on the number of syscalls that can be declared this way.

<b>Usage</b>

The following example is Linux-specific, but should work with most UNIX systems.

 #syscall [
	write: 4 [
		fd		[integer!]			;-- file descriptor, STDOUT = 1
		buffer	[c-string!]
		count	[integer!]
		return: [integer!]
	]
	quit: 1 [						;-- "exit" syscall, no return value
		status	[integer!]
	]
 ]

 msg: "Hello World"
 result: write 1 msg length? msg
 if negative? result [
 	print "Error: write failed"	
 	quit 3							;-- exit and return an error code
 ]
 quit 0								;-- no error

will output (if no error):

 Hello World
 
===Source Processing

Red/System relies on a preprocessor to make compile-time modifications of the source code in order to provide syntactic sugars, like hexadecimal and character literal forms for integers. Some features are user controlled through compiler directives like <b>#define</b> or <b>#include</b>.

---#define

The <b>#define</b> compiler directive is a rudimentary macro system that can be used to:

*define constant values

*make simple macro expressions

The name matching method is exact word matching. This ensures that no accidental source code corruption can occur.

<b>Syntax</b>

 #define <name> <value>

 <name>	 : identifier to use in the source code
 <value> : single value or block of values to replace in the source code
 
<b>Usage</b>

 #define R_PART	ff0000h				;-- simple constants definitions
 #define G_PART	00ff00h
 #define B_PART 0000ffh
 #define zero?  [0 =]				;-- simple test expression macro

 color: 550063h

 if zero? (R_PART and color) [
 	print "no Red found"
 ]
 if zero? (G_PART and color) [
  	print "no Green found"
 ]
 if zero? (B_PART and color) [
  	print "no Blue found"
 ]
 
will output:

 no Green
 
<u>Note</u>: Parens are required in this example on test expressions so that the compiler performs the second infix expression (the and operator) before the second (the equal operator).
 
---#include

The <b>#include</b> compiler directive will insert the target source file at the current position in the calling source code.

This directive helps split the source code in several files, allowing for example, to put common functions or definitions in a single place and including them where required, across several source files or across different projects.


<b>Syntax</b>

 #include %<file>

 <file> : relative or full path to a Red/System source file
 
\note Filename format
The filename must be written using the OS-independent REBOL file! format, which is documented <a href="http://www.rebol.com/docs/core23/rebolcore-12.html#section-2" target="_new">here</a>.

/note

<b>Usage</b>

Rewriting the example from <i>#include</i> section:

 definitions.reds file:

     #define R_PART	ff0000h	
 	 #define G_PART	00ff00h
 	 #define B_PART 0000ffh
 	 #define zero?  [0 =]

 	 test-primary: func [
 	 	color [integer!]
 	 	mask  [integer!]
 	 	msg   [c-string!]
 	 ][
 	 	if zero? (color and mask) [
 	 	 	print msg
 	 	]
 	 ]

 main.reds file:

     #include %definitions.reds

 	 color: 550063h

	 test-primary color R_PART "no Red found"
	 test-primary color G_PART "no Green found"
	 test-primary color B_PART "no Blue found"

===Source code organization

---Source files suffix

The official Red/System source file suffix to use is: <b>.reds</b>

---Header

Red/System enforces the usage of a standard header for all sources (this one of the great ideas in REBOL), to both identify a valid Red/System program and document it.

<b>Syntax</b>

A valid Red/System source file will need this header:

 Red/System [
  <name>: <value>
  ...								;-- more attributes...
 ]

 <name>  : valid identifier
 <value> : any Red valid datatype
 
There is no minimum or maximum number of entries that a valid header can contain, so an empty block will be also valid (but bad practice).
 
<u>Implementation note</u>: Header values types are the ones provided by REBOL during the bootstrapping phase only. Once the Red layer will be implemented, the allowed datatypes will be Red ones.

The attribute that you can specify are not limited, you can add whatever you want/need. Anyway, some attribute names are used by convention:

*<b>Title</b>:	application title

*<b>Purpose</b>: short description of the application purpose

*<b>Author</b>: source code author name

*<b>File</b>: name of the source file

*<b>Version</b>: source code version (usually using a <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.9" target="_new">tuple! literal</a>)

*<b>Date</b>: date of last version

*<b>Rights</b>: copyrights

*<b>License</b>: source license (URL or full text)

*<b>History</b>: source modifications history

*<b>Note(s)</b>: any special notice


<b>Example</b>

 Red/System [
 	Title:   "Red/System small demo app"
 	Author:  "Nenad Rakocevic"
 	File: 	 %hello.reds
 	Rights:  "Copyright (C) 2011 Nenad Rakocevic. All rights reserved."
 	License: "BSD-3 - https://github.com/dockimbel/Red/blob/master/COPYING"
 ]

---Code flow layout

A typical Red/System program is a mix of function definitions and global code (meaning executable code that is not in a function). There is no concept of "main" function in Red/System. The only entry point is the beginning of the source code and the exit point is at the end of the source code, or at a QUIT call if encountered before. 

Example:
 
 foo: 123
 print "hello"

 bar: func [a [integer!]][foo * 2]
 
 foo-twice: bar foo

 either foo < 100 [
 	print "less than 100"
 ][
	print "more than 100"
 ]

 bye: func [][print "goodbye"]

 bye

So, it is possible to mix functions and global code providing that functions are defined before they are called from global context. Such restrictions don't apply if the call is made from a function context, so cross-references like these:

 foo: func [...][...bar...]
 bar: func [...][...foo...]
 
can be processed without issues.

---Coding guidelines

<i>TBD</i>

===Integration in Red

As a dialect of Red, Red/System code will be callable from Red source code directly using one of these two methods:

<b>At runtime</b>: using the <b>DO</b> function with refinement:

	do/system [...Red/System code...]
	
<b>At compile-time</b>: using a Red compiler directive:

	#system [...Red/System code...]
	
\note Red/System functions export
It will be possible to export some Red/System functions to be callable from the Red language layer. The method for such export hasn't been decided yet. Among possible options, it can be:

*A special attribute in header that will list the functions to export

*A function's attribute in the specification block

*A compiler directive

/note

===API Reference

---Reserved keywords

The list of following keywords are reserved, they cannot be used as variables:

    alias		all			and
    any			as			comment
    either		exit		false
    forever		func		function
    if			length?		newline
    not			null		or
    pointer		return		size?
    struct		struct!		true
    until		while 		xor

---Infix operators

Infix operators take two arguments and are positioned between them.

+++Math operators

The following math operations apply on integer values. When the operation results in an exceeded memory storage limit, <i>behaviour to be defined</i>. 

<b>Addition</b>: +

 value1 + value2

<b>Subtraction</b>: -

 value1 - value2

<b>Multiplication</b>: *

 value1 * value2

<b>Division</b>: /

 value1 / value2
 
<b>Modulo</b>: //

 value1 // value2

where

 value1 : an expression returning an integer!
 value2 : expression of same datatype as <value1>
 
<u>Note:</u> for + and - operators, pointer! value can be used as first argument with an integer expression.

+++Bitwise operators

<b>Bitwise OR</b>: or

 value1 or value2

<b>Bitwise XOR</b>: xor

 value1 xor value2

<b>Bitwise AND</b>: and

 value1 and value2
 
<b>Bitwise / Logical NOT</b>: not

 not value1
 
where
 
 value1 : an expression returning an integer!, byte! or logic!
 value2 : expression of same datatype as <value1>
 
<u>Note</u>: Logical NOT will return the opposite of the logic argument (TRUE<=>FALSE), while bitwise NOT will apply one's complement on the integer argument.
 
+++Comparison operators

These operators can be used only where a condition is allowed. See "Control flow functions" section for a list of functions using conditions.

<b>Equal</b>: =

 value1 = value2
 
<b>Not equal</b>: <>

 value1 <> value2
 
<b>Greater than</b>: >
 
 value1 > value2
 
<b>Lesser than</b>: <
 
 value1 < value2
 
<b>Greater than or equal</b>: >=
 
 value1 >= value2
 
<b>Lesser than or equal</b>: <=
 
 value1 <= value2
 
where
  
  value1 : an expression returning a integer! or byte!
  value2 : expression of same datatype as <value1>

<u>Note</u>: = and <> can also be used to compare logic! or c-string! values.

+++Precedence rule

<i>TBD here or in "Expressions" chapter</i>

---Control flow functions

+++IF

Execute a block of code if a given condition is met.

<b>Syntax</b>

 if <condition> [<code>]

 <condition> : a conditional expression
 <code>		 : code to execute if the condition is met

<b>Example</b>

 if a < 0 [print "a is negative"]
 
+++EITHER

Execute a block of code if a given condition is met, else execute an alternative block of code.

<b>Syntax</b>

 either <condition> [<code>][<alternative>]

 <condition>   : a conditional expression
 <code>		   : code to execute if the condition is met
 <alternative> : code to execute if the condition is not met

<b>Example</b>

 either a < 0 [
 	either a = 0 [
 		msg: "zero"
 	][
 		msg: "negative"
 	]
 ][
 	msg: "posivite"
 ]

 prin "a is "
 print msg

+++UNTIL

Loop over a block of code until the condition at end of block, is met.

<b>Syntax</b>

 until [
 	<code>
 	<condition>
 ]

 <code>		 : code to execute while the condition is met
 <condition> : a conditional expression

<u>Note</u>: At least on loop will always be executed, even if the condition is not met from the beginning.

<b>Example</b>

 c: 5
 until [
 	prin "o"
 	c: c - 1
 	c = 0
 ]
will output:

 ooooo

+++WHILE

While a given condition is met, execute a block of code.

<b>Syntax</b>

 while [<condition>][<code>]

 <condition> : a conditional expression
 <code>		 : code to execute if the condition is met

<u>Note</u>: It is possible to execute any code in the condition block as long as it ends with a conditional expression.

<b>Example</b>

 c: 5
 while [c > 0][
 	prin "o"
 	c: c - 1
 ]
will output:

 ooooo

+++ANY

Global condition is met if at least one of the sub-conditions is met.

<b>Syntax</b>

 any [<condition-1> <condition-2> ...]

 <condition-*> : a conditional expression

<u>Note</u>:

<b>Example</b>

 if any [foo > 5 bar = 0][
 	print "true"					;-- reached if at least one condition is met
 ]

+++ALL

Global condition is met if all the sub-conditions are met.

<b>Syntax</b>

 all [<condition-1> <condition-2> ...]

 <condition-*> : a conditional expression
 
<u>Note</u>:

<b>Example</b>

 if all [foo > 5 bar = 0][
 	print "true"				 ;-- reached if both conditions are met
 ]


===Possible Evolutions

---Variables

*Add support for multiple assignments, like a: b: c: 0

---Pointers

*<strike>Remove pointer! datatype (struct! is able to do the same job)</strike> <i><b>REJECTED</b></i>

*Accept boolean operations on pointers: OR, XOR, AND (nice but use-cases would be rare?)

---Struct

*Add support for specifying struct memory alignment and padding. Default structure and members alignment would be the one specified in target object (per target). Per struct specific rules should be possible using the following syntax:

 #align <integer>				;-- change memory alignment for all subsequent
 								;-- c-strings, pointers and structs.

 struct [
	[align <n> <little|big>]	;-- change members alignment and endianess
	<members>
 ]

 <n>      : number of bytes to align members to
 <little> : little endian (optional)
 <big>    : big endian (optional)
 
*Add support for passing struct! by value when required. Possible syntax could be:

 struct [
	[by-value]					;-- 'by-value keyword would force passing it
	<members>					;-- by value.
 ]


---C-strings

*Add a FOREACH control flow function to traverse c-strings (or even array! values):
A simple way to traverse a c-string could be:

 foo: "I am a c-string"
 foreach c foo [prin c]
 
will output:
 I am a c-string
 
---Logic!

*Add logic! support for OR, XOR, AND operators (if provides any advantage over ANY/ALL).
 
---Integer!

*Bind the integer! type to int32! or int64! depending on the target platform. It needs some further investigations to determine if it can be a real advantage or not.
 
---Functions

*Add support for variable arguments number (using a block to gather them). Example:
 print ["Hello " name ", I'm" 18]

*Add support for functions refinements (same as in REBOL)

*<strike>Infer functions return value datatype</strike>
 
---New datatypes

*<b>Array!</b>: this datatype would allow declaring arrays of values that could be accessed with an integer index (similar to C arrays). Redundancy with c-string! datatype would need to be considered. Here is a draft of possible syntax and usage:
    ---- C ------               --------- Red/System ----------
	int p[20] = 0;				p: array [20 integer!]
	p[4] = 123;					p/4: 123
	p[i] = 123;					p/i: 123


*<strike>Add a uint8! (or char!) datatype</strike>

*Add a uint16! (or short!) datatype

*Add a uint64! (or long!) datatype

*<strike><b>Binary!</b>: this datatype was reserved early in the compiler's datatypes list, but not implemented. Its purpose was just to provide literal input/output forms in hexadecimal for c-string values. A standalone datatype for such purpose might be avoidable, hence the delayed implementation.</strike> <i><b>REJECTED</b></i>
 
*<strike><b>Logic!</b>: add a boolean datatype, so that booleans resulting from conditional expressions become first class citizens.</strike>
 
---New functions

*Add a FORM function (convert any datatype to c-string!)

*Add a SWITCH function: branch on different code blocks depending on a input value

*Add a INLINE function to inline machine code: inline #{1234...} and/or assembler

*<strike>Add a NOT function that would return the boolean opposite of argument value. As booleans are not really supported in the current specs, NOT addition is postponed.</strike>

*Add a REPEAT function to be able to loop with a counter:

 total: 0
 repeat c 10 [total: total + c]
 
*Add a TYPE? function returning the argument's type as integer! (should use defines to name them)

---Misc

*Add a module system (per-file contexts for example)

*<strike>Support 0 and 1 as valid boolean results</strike> <i><b>REJECTED</b></i>

*>Extend the get-word! syntax to integer! variables.

===Document History

*05/05/2011 - draft 7

*>Removed mentions for c-string variables acting as constants.

*27/04/2011 - draft 6

*>Added 'infix attribute support in functions spec block.

*>Added missing logic! datatype in functions spec block definition.

*15/04/2011 - draft 5

*>Letters in hex integers are restricted to uppercase only. Warning added for variable names that could be mistaken for hex integers.

*>Logic! support for OR, XOR, AND operators withdrawn from specifications and put in the "Possible Evolution" section. (They can be replaced by ANY/ALL/NOT to compose logic expressions)

*>'Comment added as reserved keyword

*>Added a note for = and <> operators for use with logic! values. C-string! values comparisons restricted to those two operators only (c-string! was wrongly allowed for all comparison operators).

*10/04/2011 - draft 4

*>Struct arguments are passed by reference now again. STRUCT returns a reference to the struct value.

*>Syntax now precised for STRUCT keyword followed by an alias name

*>Struct! arithmetic added

*>C-string! arithmetic added

*>Pointer! now restricted to [integer!] only. It is more consistent with c-string! and struct! which are both (implicit) pointers already.

*>Pointer! section moved after c-string! and struct! (because it is less important now)

*08/04/2011 - draft 3

*>Added get-word! syntax for getting struct variable address

*>New Possible Evolution: extend get-word! syntax to all variable types

*>Added "pointer" as reserved keyword

*>Renamed "alias-type" keyword to "alias"

*>Byte! added to <datatypes> definitions

*>Pointer syntax and declaration improved and extended to support paths with indexes

*>String! type renamed to c-string!

*>C-string path accesses now uses byte! values for reading and writing

*>Added type inference for functions local variables and return value

*>Function address can be returned using get-word! syntax

*>New "Nested functions" section added to be completed later

*>Added byte! datatype, character specific syntax moved from integer! to byte!

*>Added logic! datatype (boolean values)

*>Added TRUE and FALSE keywords

*>Added NOT operator

*>Old "Logical" operators renamed to the more appropriate "Bitwise" operators

*>Bitwise ops completed with boolean counterparts

*>More accurate syntax description for all infix operators

*>Functions local variables type is now optional if the variables are properly initialized

*>Added an empty "Type Conversion" to be completed later

*>Removed functions and macros defined in runtime from keywords, they can be redefined by user code if required

*>New Possible Evolution: integer! as a platform-specific type

*>Minor corrections and additions

*29/03/2011 - draft 2

*>Added missing array! datatype proposition in Evolutions

*>Added missing EXIT and RETURN in reserved keywords list

*28/03/2011 - draft 1

*>First public release

###

REBOL []

do/args %makedoc2.r 'load-only
doc: scan-doc read file: system/options/script
set [title out] gen-html/options doc [(options)]

file: last split-path file
replace file ".txt" ".html"
file2: copy file
insert find file2 "." "-light"
replace out "$DARK$"  file
replace out "$LIGHT$" file2

write file out
replace out "dark.css" "light.css"
write file2 out