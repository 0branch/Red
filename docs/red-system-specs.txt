Red/System Language Specifications (working draft)

	Author: Nenad Rakocevic
	Date: 29/03/2011
	Revision: 2
	Status: working draft
	Home: <a href="http://www.red-lang.org">red-lang.org</a>

===Abstract

Red/System is a dialect (<a href="http://fr.wikipedia.org/wiki/Domain-specific_programming_language" target="_new">DSL</a>) of the Red programming language. Its purpose is to provide:

*low-level system programming capabilities

*a tool to build Red's runtime low-level library

*a tool to link code and produce executables

Red/System can be seen as a C-level language with memory pointer support and a very basic and limited set of datatypes.

<u>Implementation note</u>: It is currently provided with a complete tool-chain generating executables from source files. This is a temporary state as Red/System will live inside Red, so will be embedded in Red scripts.

===Syntax

The syntax is almost the same as the one used by REBOL language, as the lexer (<a href="http://www.rebol.com/docs/words/wload.html" target="_new">LOAD</a>) is currently provided by REBOL during the bootstrapping phase. The REBOL syntax doesn't have a formal specification nor an exhaustive documentation, just a superficial description, but it is enough to work with. See:

*<a href="http://www.rebol.com/docs/core23/rebolcore-3.html" target="_new">http://www.rebol.com/docs/core23/rebolcore-3.html</a> (There is a typo in the table, all literals are missing a caret (^) character after the first quote)

*<a href="http://www.rebol.com/r3/docs/guide/code-syntax.html" target="_new">http://www.rebol.com/r3/docs/guide/code-syntax.html</a>

A complete syntax specification for both Red and Red/System will be provided during the implementation of the Red language layer.

For now, Red/System uses 8-bit character encoding (ASCII). Once proper Unicode support will be provided by the Red language layer, Red/System will switch to UTF-8 source encoding.

---Comments

 ;this is a commented line

 print "hello world"    ; this is another comment

 comment {
     This is a
     multiline
     comment
 }

===Variables

Variables are labels used to represent a memory location. The labels (called <b>identifiers</b> from now) are formed by sequences of printable characters without any blank (space, newlines or tabulation). Printable characters are defined as any one-byte character in the 20h-7Fh range that can be printed out in system's console excepting the following ones (used as delimiters or reserved for some datatypes literals): 

 [ ] { } " ( ) / @ # $ % ^ , : ;
    
There is also a restriction on the first character, the following characters are forbidden in the first position, but allowed at other positions:

 0 1 2 3 4 5 6 7 8 9
 
All identifiers (variables and function names) are <u>case-insensitive</u>.

---Set a value

Variables can hold any value of the available datatypes. This can be the real value (like integer! or pointer!) or a reference to the real value as is the case for struct! or string!). To assign a value to a variable, use a colon character at the end of the variable identifier.

 foo: 123
 bar: "hello"

\note Multiple assignments
Multiple assignments, like a: b: 123, are not supported in Red/System. Such feature could be added in the future if required.

/note

---Get a value

Just use the variable without any decoration to get its value or to pass it as a function's argument.

 bar: "hello"
 print bar

will output:
 hello
 
---Variable's type

Variables do have a type. Global variables do not need to be declared before being used, but they require to be <u>initialized</u> anyway. Functions variables always require a declaration that specify its type. For example:

 foo: 123
 bar: "hello"
 size: length? bar
 id: GetProcessID						;-- 'GetProcessID would return an integer!
 
are valid variable usages.

Allowed types are:

*integer!

*pointer!

*string!

*struct!



===Datatypes

---Integer!

+++Syntax

 decimal form          :  1234

 decimal negative form : -1234

 hexadecimal form      :  4D2h

Integer datatype represents natural and negative natural numbers. The memory size of an integer is 32 bits, so the range of supported numbers is : 

 -2147483648 to 2147483647
    
+++Alternative literal formats

<b>Character format</b>

Used to represent only byte range from 0 to 255. Examples of some character representations

 #"a"
 #"A"
 #"5"
 #"^A"
 #"^(1A)"
 #"^(back)"
 
See <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1" target="_new">http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1</a> for a more complete description of this format.

\note Character as input format only
The character literal format is a syntactic sugar offered by Red/System to represent bytes in source code in a more readable way. During the lexical analysis, all character literals are replaced by their ASCII value.

/note

<b>Hexadecimal format</b>

Hexadecimal integer representation is mostly used to represent memory addresses or binary data for boolean operations. As for character, all hexadecimal literals found in sources are converted to their integer decimal value during lexical analysis. Allowed range is:
    
 00000000h to FFFFFFFFh

\note Hex literal form design decision
The 0x prefix is often used to mark a literal hexadecimal value. It could have been used in Red/System too if the &lt;number&gt;x&lt;number&gt; literal form wasn't reserved in Red for the pair! datatype. As Red/System is a dialect of Red, it has to use the same representation for hex values, so <b>&lt;hexa&gt;h</b> was chosen instead.

/note

---Pointer!

Pointer datatype purpose is to hold the memory address of another value. A pointer value is defined by the pointed value address and datatype. 

<u>Implementation note</u>: The memory size of a pointer is 4 bytes on 32-bit systems (and 8 bytes on 64-bit systems).

+++Declaration

 &[<datatype> <address>]

 <datatype>: integer! | pointer! [<datatype>] | string! | struct! [<members>]
 <address> : initial memory address to point to (integer!)

Declaration examples (with C equivalents):

 p: &[integer! 0]						;-- int *p = 0;
 p: &[string! 0]						;-- char *p = 0;
 p: &[pointer! [string!] 0]				;-- char **p = 0
 p: &[struct! [count [integer!]] 0]		;-- struct {int count;} *p = 0;
 
<u>Note</u>: Pointer! and struct! values require an additional specification block.

+++Dereferencing

Dereferencing a pointer is the operation allowing to access the pointed value. In Red/System, it is achieved by adding a <b>/value</b> refinement to the pointer variable (called more generally "path notation"):

 <pointer>/value						;-- read access
 <pointer>/value: <value>				;-- write access

 <pointer> : pointer variable
 <value>   : a value of same type as in pointer's definition

Usage example

 p:   &[integer! 4000000h]				;-- declare a pointer on an integer
 bar: &[integer! 0]						;-- declare another pointer on an integer

 p/value: 1234 							;-- write 1234 at address 40000000h
 foo: p/value							;-- read pointed value back
 bar: p									;-- assign pointer address to 'bar
 
<u>Note</u>: Remember that a pointed value is undefined (can contain an arbitrary value) until you define it explicitly  

+++Pointer Arithmetic

It is possible to apply some simple math operations on pointer like additions and subtractions (as in C). Pointer address would be increased or decreased by the memory size of the pointed value multiplied by the amount to respectively add or subtract.

 p: &[integer! 4000000h]				;-- pointed value memory size is 4 bytes
 p: p + 1								;-- p points now to 40000004h
 p: p + 1								;-- p points now to 40000008h

Another example with a bigger pointed value:

 p: &[struct! [							;-- value memory size is 8 bytes
 		a [integer!]
 		b [pointer! [integer!]]
 	]
 	4000000h
 ]
 p: p - 1								;-- p points now to 3FFFFFF8h 


---String!

A string! value is a sequence of not-null bytes terminated by a null byte. A string variable holds the address of the first byte of the string. A string having a null character as first byte is an empty string.

+++Syntax

Literal strings are defined using double quotes delimiters or a pair of matching curly braces:

 foo: "I am a string"
 bar: {I am
   a multiline
   string
 }
 
\note String null byte ending
You don't have to add a null byte to literal strings, it is added automatically during compilation.

/note

+++String length

It is possible to retrieve the number of bytes (<b>excluding the null</b> end marker) in a string at runtime using the LENGTH? function:

 a: length? "Hello"						;-- here length? will return 5
 
\noteLength? vs Size?
Do not confuse the LENGTH? function with the SIZE? function (see ...)

/note

+++Accessing bytes

It is possible to access individual bytes in a string using path notations:

 <string>/integer!						;-- literal integer index provided
 <string>/<index>						;-- index provided by a variable

 <string> : a string variable
 <index>  : an integer variable

Examples:

 foo: "I am a string"
 foo/1  =>  73							;-- ASCII code of "I"
 foo/2  =>  32							;-- ASCII code of a space
 ...
 foo/13 => 103							;-- ASCII code of "g"
 foo/14 =>   0							;-- ASCII code of null (end marker)
 
<u>Note</u>: In contrary to the C language, indexes in Red/System are <u><b>one-based</b></u>.

Example of a variable used as index:

 c: 4
 foo/c  => 109							;-- ASCII code of "m"

A simple way to traverse a string would be:

 foo: "I am a string"
 c: 1
 until [
 	prin form foo/c					;-- form would convert an ASCII code to a string
 	c: c + 1
 	zero? foo/c
 ]
 
will output:
 I am a string

Similary, it is also possible to write bytes using path notation with an ending colon:

 <string>/integer!:	<value>				;-- literal integer index provided
 <string>/<index>:	<value>				;-- index provided by a variable

 <string> : a string variable
 <index>  : an integer variable
 <value>  : a 8-bit integer value

For example:

 foo: "I am a string"
 foo/3: #"-"
 c: 4
 foo/c: #"-"
 print foo
 
will output
 I -- a string

---Struct!

Struct! datatype is roughly equivalent to C struct type. It is a record of one or several values, each value having its own datatype.

<u>Implementation note</u>: Struct! values are <u>padded</u> (at tail) in memory in order to preserve optimal alignment for each target (for example, it is aligned to 4 bytes for IA32 target). SIZE? function will return the size of the struct! value in memory without the eventual padding .

+++Declaration

Declaring a struct! value is achieved by using the STRUCT keyword followed by a specification block. That block defines struct! value members using pairs of name and datatype definition.

 struct [
 	<member> [<datatype>]
 	...
 ]
 
 <member>   : a valid identifier
 <datatype> : integer! | pointer! [<datatype>] | string! | struct! [<members>]

+++Usage

 s: struct [
 	a 	[integer!]
 	b	[string!]
 	c 	[struct! [d [integer!]]]
 ]
 
In this example, the struct value has 3 members: a, b, c, each with a different datatype.

Remember that struct! values are always passed by reference to other variables and functions:

 foo: s									;-- assign 's struct address to 'foo
 bar s									;-- pass 's struct address as argument
 
\notePassing by value?
There is currently no way to pass a struct! data as value to a function or to copy it within another variable. If the need for such feature arises, this specification will be extended to support it.

/note

+++Accessing members

Member access is achieved using path notation. Syntax is:

 <struct>/<member>						;-- read access
 <struct>/<member>: <value>				;-- write access

 <struct>  : a valid struct variable
 <member>  : a valid member identifier in <struct>
 <value>   : a value of same datatype as <member>


From last example, that would give:

 foo: s/a								;-- reading member 'a in struct 's
 s/a: 123								;-- writing a value in member 'a in struct 's
 s/b: "hello"
 bar: s/c/d								;-- deep read/write access is also possible

+++Aliases

Struct! values definitions tend to be quite long, so in some cases, when struct! definitions are required to be inserted in other struct! definitions or in functions specification block, it is possible to use an alias name to reference a struct! definition through the source code. It also allows to solve the self-referencing case quite simply.

<u>Note</u>: remember that an alias is not a value, it doesn't take any space in memory, it can be seen as a <i>virtual datatype</i>. So, by convention, alias names should end with a exclamation mark, in order to distinguish them more easily from variables in the source code.

Aliasing syntax:

 <name>: alias-type struct! [
 	<member> [<datatype>]
 	...
 ]
 
 <name>     : the name to use as alias
 <member>   : a valid identifier
 <datatype> : integer! | pointer! [<datatype>] | string! | struct! [<members>]
 
Usage example:

 book!: alias-type struct! [			;-- defines a new aliased type
 	title		[string!]
 	author	 	[string!]
 	year		[integer!]
 	last-book 	[book!]					;-- self-referenced definition
 ]

 gift: struct [
 	first  [book!]
 	second [book!]
 ]
 b: gift/first

 b/title:  "Contact"
 b/author: "Carl Sagan"
 b/year:   1985
 
\noteAlias-type keyword
The keyword ALIAS-TYPE might be change in the future for a shorter form like ALIAS.

/note

---Type Casting

Type casting is possible between value of compatible types. Compatible types are defined as types which values memory size is equal. Casting is achieved using the <b>AS</b> keyword followed by the target type and the value to cast.

<u>Note</u>: Trying to assign a value to a variable of incompatible type will result in a compilation error. The same action with a compatible type will trigger a compilation warning, asking to add explicit casting or fix the issue if casting was not intended.

Syntax:

 as <new-type> value

 <new-type> : integer! | pointer! [<datatype>] | string! | struct! [<members>]

Example:

 foo: 0									;-- foo is an integer
 bar: &[pointer! [string!]]				;-- bar is a pointer

 foo: as integer! bar					;-- explicit type casting
 bar: as [pointer! [string!]] foo		;-- complex type is passed as a block

===Expressions

<i>TBD</i>

===Functions

Function definition and usage is pretty straightforward in Red/System. The function specification block contains all the definitions required by the function. This includes:

*calling arguments

*optional returned value type

*local variables

---Declaration

<b>Syntax</b>

 <name>: func | function [
 	<argument> [<datatype>]
 	...
 	return: [<datatype>]				;-- returned value type (optional part)
 	/local								;-- local variables (optional part)
 	<local> [<datatype>]
 	...
 ][
 	<body>
 ]

 <name>		: function's name
 <argument>	: function's argument indentifier
 <datatype>	: integer! | pointer! [<datatype>] | string! | struct! [<members>]
 <local>	: local variable
 <body>		: function's body code

<b>Examples</b>

 hello: func [][print "hello"]			;-- no arguments, no locals, no return value

 why?: func [return: [integer!]][42]	;-- minimal function returning an integer

 inc: func [							;-- increment an integer
 	a 		[integer!]
 	return: [integer!]
 ][
 	a + 1								;-- last value is returned
 ]

 percent?: func [						;-- return relative percentage of a / b
 	a [integer!]
 	b [integer!]
 	return: [integer!]
 	/local								;-- declare local variables
 	c [integer!]
 ][
 	c: 100
 	a * c / b
 ]

---Return value

Any function is able to return a value if necessary. This is trivially achieved as last expression in function's body will be automatically returned if:

*a RETURN: statement is present in function's spec block

*last expression datatype matches the one declared after the RETURN: statement

---Calling a function

Calling a function is achieved by writing its name followed by the required number of arguments.

<i>(from the previous examples)</i>
 hello									;-- will print "hello" in the standard output

 answer: why?							;-- will return 42 in variable 'answer

 foo: 4
 foo: inc foo							;-- foo holds 5 after the call to 'inc

 bar: percent? 3 4						;-- bar holds 75
 
It is also possible to pipe several function calls together:

 foo: percent? 11 inc inc why?			;-- will return 25 in foo

---Premature exiting

Exiting at function's end is not always desirable. Sometimes, conditional premature exiting from the function is required. This can be done using EXIT or RETURN special keywords.

+++Exit

Quits immediatly the function.

 test: func [a [integer!]][
 	if zero? a [exit]					;-- exit the function here if a = 0
 	...									;-- if a <> 0, continue processing...
 ]
 
 
+++Return
 
Quits immediatly the function and returns a value.

 test: func [
 	a [integer!]
 	return: [string!]
 ][
 	if zero? a [
 		return "Not allowed"			;-- exit the function here if a = 0
 	]
 	"ok"								;-- return "ok" if a <> 0
 ]


===Scoping

In Red/System, variables are statically scoped. The place in source code where a variable is declared determines its scope. 

---Global Context

Global context is defined as the global namespace where all global variables and functions are defined. This context is unique. As a simple rule, every variable not declared in a function is a global variable bound to global context.

Example:

 foo: 123								;-- global variable

 f: func [/local bar [integer!]][
 	bar: 123							;-- locally scoped variable
 ]

---Functions Contexts

Each defined function has its own local context. Variables declared in function's definition block are locally scoped and can't be accessed outside of the function's body. On the other hand, global variable can be referenced and modified from functions. If a local variable has the same name as a global one, the local one will take precedence in function's body. The value of the homonym global variable won't be affected by local redefinitions in functions contexts.

Example:

 foo: 1									;-- global variable
 var: 2

 f: func [
 	return:    [integer!]
 	/local 
 		bar [integer!]
 ][
 	bar: 3
 	foo + var + bar						;-- will return 6
 ]

 f: func [
 	return:    [integer!]
 	/local 
 		bar [integer!]
 		var [integer!]
 ][
 	bar: 3
 	var: 10								;-- 'var is a local variable here
 	foo + var + bar						;-- will return 14
 ]



===Compiler directives

Some features of Red/System need to be processed at compile-time rather than at runtime. This is especially true for features related to the linking phase that builds the executable file. In order to distinguish such compile-time commands or options, compiler directive are introduced. Their syntax is:

 #<directive> <argument-1> <argument-2> ...

 <directive>  : a valid identifier
 <argument-*> : argument can be any Red valid datatype
 
The number of argument is specific to each compiler directive.
 
<u>Implementation note</u>: Directives arguments datatype set is the one provided by REBOL during the bootstrapping phase only. Once the Red layer will be implemented, the allowed datatypes will be Red ones.


===Importing External Libraries

---#import

Red/System is able to dynamically load external shared libraries when a Red/System executable is loaded by the operating system. This requires that the programmer gives instructions to the compiler about which library to load and how to map library's functions to Red/System global context. This feature is called "library import" in Red/System and it is supported by a specific compiler directive: <b>#import</b>. This directive can be used anywhere in the global context of your Red/System program, but pay attention to put it <i>before</i> you use one of the mapped functions, else a compiler error will be raised. This directive can be used multiple times in your source code if it makes it more readable. If there is a huge number of functions to imports, putting them in separate includes files would be considered as a good practice.

<u>Note</u>: this is not the same as dynamically loading a shared library from your Red/System code after your program has started. Such approach allows you to delay the loading of your libraries and to free them. Imports cannot be freed.

<b>Syntax</b>

 #import [
 	"<library>" <convention> [
 		<function name>: "<ID>" [
 			<argument> [<datatype>]
 			...
 			return: [<datatype>]		;-- optional part
 		]
 		...								;-- more functions mappings
 	]
 	...									;-- more libraries to load					
 ]

 <library>		 : shared library file name (with extension)
 <convention>	 : calling convention of the library (stdcall | cdecl)
 <function name> : name of the mapped function in global context
 <ID>			 : identifier of the function in the shared library
 <argument>		 : function's argument indentifier
 <datatype>		 : integer! | pointer! [<datatype>] | string! | struct! [<members>]

The <b>RETURN:</b> statement indicates that the mapped function has a return value.

There's no limitation on the number of libraries or functions that can be declared this way.

Supported calling conventions are:

*<a href="http://en.wikipedia.org/wiki/X86_calling_conventions#stdcall" target="_new">stdcall</a>: used mostly by Windows API (but can be also used by third-party DLLs)

*<a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl" target="_new">cdecl</a>: default calling convention used by C shared libraries.

<b>Usage</b>

The following example is Windows-specific. 

 #import [
 	"kernel32.dll" stdcall [
 		process-id?: "GetCurrentProcessId" [
 			return: [integer!]
 		]
 		get-env: "GetEnvironmentVariableA" [
 			name 	[string!]
 			buffer	[string!]
 			size	[integer!]
 			return: [integer!]
 		]
 	]
 	"msvcrt.dll" stdcall [
 		malloc: "malloc" [
 			size 	[integer!]
 			return: [string!]
 		]
 		free: "free" [
 			block	[string!]
 		]
 	]
 ]

 pid: process-id?

 max-size: 128
 buf: malloc  max-size						;-- allocate space for 127 characters

 get-env "windir" buf  max-size

 print buf
 free buf
 
would output:

 C:\Windows


---#syscall

As Red/System is destined to be used mostly for low-level system programming, <a href="http://en.wikipedia.org/wiki/System_call" target="_new">syscalls</a> mappings are also supported using the <b>#syscall</b> compiler directive.

<b>Syntax</b>

 #syscall [
 	<function name>: <ID> [
  		<argument> [<datatype>]
		...
		return: [<datatype>]		;-- optional part
	]
	...								;-- more functions mappings
 ]
 
  <function name> : name of the mapped function in global context
  <ID>			  : syscall integer ID
  <argument>	  : syscall's argument indentifier
  <datatype>	  : integer! | pointer! [<datatype>] | string! | struct! [<members>]

The <b>RETURN:</b> statement indicates that the mapped syscall has a return value.

There's no limitation on the number of syscalls that can be declared this way.

<b>Usage</b>

The following example is Linux-specific, but should work with most UNIX systems.

 #syscall [
	write: 4 [
		fd		[integer!]			;-- file descriptor, STDOUT = 1
		buffer	[string!]
		count	[integer!]
		return: [integer!]
	]
	quit: 1 [						;-- "exit" syscall, no return value
		status	[integer!]
	]
 ]

 msg: "Hello World"
 result: write 1 msg length? msg
 if negative? result [
 	print "Error: write failed"	
 	quit 3							;-- exit and return an error code
 ]
 quit 0								;-- no error

will output (if no error):

 Hello World
 
===Source Processing

Red/System relies on a preprocessor to make compile-time modifications of the source code in order to provide syntactic sugars, like hexadecimal and character literal forms for integers. Some features are user controlled through compiler directives like <b>#define</b> or <b>#include</b>.

---#define

The <b>#define</b> compiler directive is a rudimentary macro system that can be used to:

*define constant values

*make simple macro expressions

The name matching method is exact word matching. This ensures that no accidental source code corruption can occur.

<b>Syntax</b>

 #define <name> <value>

 <name>	 : identifier to use in the source code
 <value> : single value or block of values to replace in the source code
 
<b>Usage</b>

 #define R_PART	ff0000h				;-- simple constants definitions
 #define G_PART	00ff00h
 #define B_PART 0000ffh
 #define zero?  [0 =]				;-- simple test expression macro

 color: 550063h

 if zero? (R_PART and color) [
 	print "no Red found"
 ]
 if zero? (G_PART and color) [
  	print "no Green found"
 ]
 if zero? (B_PART and color) [
  	print "no Blue found"
 ]
 
will output:

 no Green
 
<u>Note</u>: Parens are required in this example on test expressions so that the compiler performs the second infix expression (the and operator) before the second (the equal operator).
 
---#include

The <b>#include</b> compiler directive will insert the target source file at the current position in the calling source code.

This directive helps split the source code in several files, allowing for example, to put common functions or definitions in a single place and including them where required, across several source files or across different projects.


<b>Syntax</b>

 #include %<file>

 <file> : relative or full path to a Red/System source file
 
\note Filename format
The filename must be written using the OS-independent REBOL file! format, which is documented <a href="http://www.rebol.com/docs/core23/rebolcore-12.html#section-2" target="_new">here</a>.

/note

<b>Usage</b>

Rewriting the example from <i>#include</i> section:

 definitions.reds file:

     #define R_PART	ff0000h	
 	 #define G_PART	00ff00h
 	 #define B_PART 0000ffh
 	 #define zero?  [0 =]

 	 test-primary: func [
 	 	color [integer!]
 	 	mask  [integer!]
 	 	msg   [string!]
 	 ][
 	 	if zero? (color and mask) [
 	 	 	print msg
 	 	]
 	 ]

 main.reds file:

     #include %definitions.reds

 	 color: 550063h

	 test-primary color R_PART "no Red found"
	 test-primary color G_PART "no Green found"
	 test-primary color B_PART "no Blue found"

===Source code organization

---Source files suffix

The official Red/System source file suffix to use is: <b>.reds</b>

---Header

Red/System enforces the usage of a standard header for all sources (this one of the great ideas in REBOL), to both identify a valid Red/System program and document it.

<b>Syntax</b>

A valid Red/System source file will need this header:

 Red/System [
  <name>: <value>
  ...								;-- more attributes...
 ]

 <name>  : valid identifier
 <value> : any Red valid datatype
 
There is no minimum or maximum number of entries that a valid header can contain, so an empty block will be also valid (but bad practice).
 
<u>Implementation note</u>: Header values types are the ones provided by REBOL during the bootstrapping phase only. Once the Red layer will be implemented, the allowed datatypes will be Red ones.

The attribute that you can specify are not limited, you can add whatever you want/need. Anyway, some attribute names are used by convention:

*<b>Title</b>:	application title

*<b>Purpose</b>: short description of the application purpose

*<b>Author</b>: source code author name

*<b>File</b>: name of the source file

*<b>Version</b>: source code version (usually using a <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.9" target="_new">tuple! literal</a>)

*<b>Date</b>: date of last version

*<b>Rights</b>: copyrights

*<b>License</b>: source license (URL or full text)

*<b>History</b>: source modifications history

*<b>Note(s)</b>: any special notice


<b>Example</b>

 Red/System [
 	Title:   "Red/System small demo app"
 	Author:  "Nenad Rakocevic"
 	File: 	 %hello.reds
 	Rights:  "Copyright (C) 2011 Nenad Rakocevic. All rights reserved."
 	License: "BSD-3 - https://github.com/dockimbel/Red/blob/master/COPYING"
 ]

---Code flow layout

A typical Red/System program is a mix of function definitions and global code (meaning executable code that is not in a function). There is no concept of "main" function in Red/System. The only entry point is the beginning of the source code and the exit point is at the end of the source code, or at a QUIT call if encountered before. 

Example:
 
 foo: 123
 print "hello"

 bar: func [a [integer!]][foo * 2]
 
 foo-twice: bar foo

 either foo < 100 [
 	print "less than 100"
 ][
	print "more than 100"
 ]

 bye: func [][print "goodbye"]

 bye

So, it's possible to mix functions and global code providing that functions are defined before they are called from global context. Such restriction don't apply if the call is made from a function context, so cross-references like these:

 foo: func [...][...bar...]
 bar: func [...][...foo...]
 
can be processed without issues.

---Coding guidelines

<i>TBD</i>

===Integration in Red

As a dialect of Red, Red/System code will be callable from Red source code directly using one of these two methods:

<b>At runtime</b>: using the <b>DO</b> function with refinement:

	do/system [...Red/System code...]
	
<b>At compile-time</b>: using a Red compiler directive:

	#system [...Red/System code...]
	
\note Red/System functions export
It will be possible to export some Red/System functions to be callable from the Red language layer. The method for such export hasn't been decided yet. Among possible options, it can be:

*A special attribute in header that will list the functions to export

*A function's attribute in the specification block

*A compiler directive

/note

===API Reference

---Reserved keywords

The list of following keywords are reserved, they cannot be used as variables:

 alias-type		all			and
 any			as			either
 exit			forever		func
 function		if			length?
 negative?		newline		not
 null			or			positive?
 prin			print		quit
 return			size?		stdout
 struct			struct!		until
 while			xor			zero?

---Infix operators

Infix operators take two arguments and are positioned between them.

+++Math operators

The following math operations apply on integer values. When the operation results in an exceeded memory storage limit, <i>behaviour to be defined</i>. 

<b>Addition</b>: +

 <value> + <value>

<b>Subtraction</b>: -

 <value> - <value>

<b>Multiplication</b>: *

 <value> * <value>

<b>Division</b>: /

 <value> / <value>
 
<b>Modulo</b>: //

 <value> // <value>

where

 <value> : an integer (literal, variable, function return value)
 
<u>Note:</u> for + and - operators, pointer! value can be used as first argument with an integer (literal, variable, function return value)

+++Logic operators

<b>Logical OR</b>: or

 <value> or <value>

<b>Logical XOR</b>: xor

 <value> xor <value>

<b>Logical AND</b>: and

 <value> and <value>
 
where
 
 <value> : an integer (literal, variable, function return value)

+++Comparison operators

These operators can be used only where a condition is allowed. See "Control flow functions" section for a list of functions using conditions.

<b>Equal</b>: =

 <value> = <value>
 
<b>Not equal</b>: <>

 <value> <> <value>
 
<b>Greater than</b>: >
 
 <value> > <value>
 
<b>Lesser than</b>: <
 
 <value> < <value>
 
<b>Greater than or equal</b>: >=
 
 <value> >= <value>
 
<b>Lesser than or equal</b>: <=
 
 <value> <= <value>

+++Precedence rule

<i>TBD here or in "Expressions" chapter</i>

---Control flow functions

+++IF

Execute a block of code if a given condition is met.

<b>Syntax</b>

 if <condition> [<code>]

 <condition> : a conditional expression
 <code>		 : code to execute if the condition is met

<b>Example</b>

 if a < 0 [print "a is negative"]
 
+++EITHER

Execute a block of code if a given condition is met, else execute an alternative block of code.

<b>Syntax</b>

 either <condition> [<code>][<alternative>]

 <condition>   : a conditional expression
 <code>		   : code to execute if the condition is met
 <alternative> : code to execute if the condition is not met

<b>Example</b>

 either a < 0 [
 	either a = 0 [
 		msg: "zero"
 	][
 		msg: "negative"
 	]
 ][
 	msg: "posivite"
 ]

 prin "a is "
 print msg

+++UNTIL

Loop over a block of code until the condition at end of block, is met.

<b>Syntax</b>

 until [
 	<code>
 	<condition>
 ]

 <code>		 : code to execute while the condition is met
 <condition> : a conditional expression

<u>Note</u>: At least on loop will always be executed, even if the condition is not met from the beginning.

<b>Example</b>

 c: 5
 until [
 	prin "o"
 	c: c - 1
 	c = 0
 ]
will output:

 ooooo

+++WHILE

While a given condition is met, execute a block of code.

<b>Syntax</b>

 while [<condition>][<code>]

 <condition> : a conditional expression
 <code>		 : code to execute if the condition is met

<u>Note</u>: It is possible to execute any code in the condition block as long as it ends with a conditional expression.

<b>Example</b>

 c: 5
 while [c > 0][
 	prin "o"
 	c: c - 1
 ]
will output:

 ooooo

+++ANY

Global condition is met if at least one of the sub-conditions is met.

<b>Syntax</b>

 any [<condition-1> <condition-2> ...]

 <condition-*> : a conditional expression

<u>Note</u>:

<b>Example</b>

 if any [foo > 5 bar = 0][
 	print "true"					;-- reached if at least one condition is met
 ]

+++ALL

Global condition is met if all the sub-conditions are met.

<b>Syntax</b>

 all [<condition-1> <condition-2> ...]

 <condition-*> : a conditional expression
 
<u>Note</u>:

<b>Example</b>

 if all [foo > 5 bar = 0][
 	print "true"				 ;-- reached if both conditions are met
 ]


===Possible Evolutions

---Variables

*Add support for multiple assignments, like a: b: c: 0

---Pointers

*Remove pointer! datatype (struct! is able to do the same job)

*Accept boolean operations on pointers: OR, XOR, AND (nice but use-cases would be rare)

---Strings

*Add a FOREACH control flow function to traverse strings (or even array! values):
A simple way to traverse a string could be:

 foo: "I am a string"
 foreach c foo [prin c]
 
will output:
 I am a string
 
---Functions

*Add support for variable arguments number (using a block to gather them)

*Add support for functions refinements (same as in REBOL)

*Infer functions return value datatype
 
---New datatypes

*<b>Array!</b>: this datatype would allow declaring arrays of values that could be accessed with an integer index (similar to C arrays). Redundancy with string! datatype would need to be considered. Here is a draft of possible syntax and usage:
    ---- C ------               --------- Red/System ----------
	int p[20] = 0;				p: &[array! [20 integer!] 0]
	p[4] = 123;					p/4: 123
	p[i] = 123;					p/i: 123


*Add a uint8! (or char!) datatype

*Add a uint16! (or short!) datatype

*Add a uint64! (or long!) datatype

*<b>Binary!</b>: this datatype was reserved early in the compiler's datatypes list, but not implemented. Its purpose was just to provide literal input/output forms in hexadecimal for string values. A standalone datatype for such purpose might be avoidable, hence the delayed implementation.
 
*<b>Logic!</b>: add a boolean datatype, so that booleans resulting from conditional expressions become first class citizens.
 
---New functions

*Add a FORM function (convert any datatype to string!)

*Add a SWITCH function: branch on different code blocks depending on a input value

*Add a INLINE function to inline machine code: inline #{1234...} and/or assembler

*Add a NOT function that would return the boolean opposite of argument value. As booleans are not really supported in the current specs, NOT addition is postponed.

*Add a REPEAT function to be able to loop with a counter:

 total: 0
 repeat c 10 [total: total + c]

---Misc

*Support 0 and 1 as valid boolean results

*Add a module system (per-file contexts for example)

===Document History

*29/03/2011 - draft 2

*>Added missing array! datatype proposition in Evolutions

*>Added missing EXIT and RETURN in reserved keywords list

*28/03/2011 - draft 1

*>First public release

###

REBOL []

do/args %makedoc2.r 'load-only
doc: scan-doc read file: system/options/script
set [title out] gen-html/options doc [(options)]

file: last split-path file
replace file ".txt" ".html"
file2: copy file
insert find file2 "." "-light"
replace out "$DARK$"  file
replace out "$LIGHT$" file2

write file out
replace out "dark.css" "light.css"
write file2 out