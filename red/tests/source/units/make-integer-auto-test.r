REBOL [
  Title:   "Generates Red integer! tests"
	Author:  "Peter W A Wood"
	File: 	 %make-integer-auto-test.r
	Version: 0.1.0
	Tabs:	 4
	Rights:  "Copyright (C) 2011-2012 Peter W A Wood. All rights reserved."
	License: "BSD-3 - https://github.com/dockimbel/Red/blob/origin/BSD-3-License.txt"
]

;; initialisations 
tests: copy ""                          ;; string to hold generated tests
test-number: 0                          ;; number of the generated test
make-dir %auto-tests/
file-out: %auto-tests/integer-auto-test.red

;; create a block of values to be used in the binary ops tests
test-values: [
            0                   ; zero
  -2147483648                   ; min
   2147483647                   ; max
                                ;; DO NOT USE -1 as it crashes REBOL !!!!
            3
           -7
            5
       123456
        28230
        -6681
        44095
        65536
]


;; create blocks of operators to be applied
test-binary-ops: [
  +
  -
  *
  /
  ;//
  ;or
  ;xor
  ;and
]

test-no-zeroes: [         ;; zero not allowed as operand2
  / 
  ;//
]

test-comparison-ops: [
  =
  <>
  <
  >
  >=
  <=
]

test-comparison-values: [
  -1
  0
  +1
]

;; create test file with header
append tests "Red [^(0A)"
append tests {  Title:   "Red auto-generated integer! tests"^(0A)}
append tests {	Author:  "Peter W A Wood"^(0A)}
append tests {  File: 	 %integer-auto-test.red^(0A)}
append tests {  License: "BSD-3 - https://github.com/dockimbel/Red/blob/origin/BSD-3-License.txt"^(0A)}
append tests "]^(0A)^(0A)"
append tests "^(0A)^(0A)comment {"
append tests "  This file is generated by make-integer-auto-test.r^(0A)"
append tests "  Do not edit this file directly.^(0A)"
append tests "}^(0A)^(0A)"
append tests join ";make-length:" 
                  [length? read %make-integer-auto-test.r "^(0A)^(0A)"]
append tests {
;; counters
qt-run-tests: 0 
qt-run-asserts: 0
qt-run-passes: 0
qt-run-failures: 0
qt-file-tests: 0 
qt-file-asserts: 0 
qt-file-passes: 0 
qt-file-failures: 0

;; group switches
qt-group-name-not-printed: true
qt-group?: false

_qt-init-group: func [] [
  qt-group-name-not-printed: true
  qt-group?: false
  qt-group-name: ""
]

qt-init-run: func [] [
  qt-run-tests: 0 
  qt-run-asserts: 0
  qt-run-passes: 0
  qt-run-failures: 0
  _qt-init-group
]

qt-init-file: func [] [
  qt-file-tests: 0 
  qt-file-asserts: 0 
  qt-file-passes: 0 
  qt-file-failures: 0
  _qt-init-group
]

***start-run***: func[
    title [string!]
][
  qt-init-run
  qt-run-name: title
  prin "***Starting*** " 
  print title
]

~~~start-file~~~: func [
  title [string!]
][
  qt-init-file
  prin "~~~started test~~~ "
  print title
  qt-file-name: title
  qt-group?: false
]

===start-group===: func [
  title [string!]
][
  qt-group-name: title
  qt-group?: true
]

--test--: func [
  title [string!]
][
  qt-test-name: title
  qt-file-tests: qt-file-tests + 1
]

--assert: func [
  assertion [logic!]
][

  qt-file-asserts: qt-file-asserts + 1
  
  either assertion [
     qt-file-passes: qt-file-passes + 1
  ][
    qt-file-failures: qt-file-failures + 1
    if qt-group? [  
      if qt-group-name-not-printed [
        prin "===group=== "
        print qt-group-name
        qt-group-name-not-printed: false
      ]
    ]
    prin "--test-- " 
    prin qt-test-name
    print " FAILED**************"
  ]
]
 
===end-group===: func [] [
  _qt-init-group
]

qt-print-totals: func [
  tests     [integer!]
  asserts   [integer!]
  passes    [integer!]
  failures  [integer!]
][
  prin  "  Number of Tests Performed:      " 
  print tests 
  prin  "  Number of Assertions Performed: "
  print asserts
  prin  "  Number of Assertions Passed:    "
  print passes
  prin  "  Number of Assertions Failed:    "
  print failures
  if failures <> 0 [
    print "****************TEST FAILURES****************"
  ]
]

~~~end-file~~~: func [] [
  print ""
  prin "~~~finished test~~~ " 
  print qt-file-name
  qt-print-totals qt-file-tests qt-file-asserts qt-file-passes qt-file-failures
  print ""
  
  ;; update run totals
  qt-run-passes: qt-run-passes + qt-file-passes
  qt-run-asserts: qt-run-asserts + qt-file-asserts
  qt-run-failures: qt-run-failures + qt-file-failures
  qt-run-tests: qt-run-tests + qt-file-tests
]

***end-run***: func [][
  prin "***Finished*** "
  print qt-run-name
  qt-print-totals qt-run-tests
                  qt-run-asserts
                  qt-run-passes
                  qt-run-failures
]
             
}
append tests {~~~start-file~~~ "Auto-generated tests for integers"^(0A)^(0A)}
append tests {===start-group=== "Auto-generated tests for integers"^(0A)^(0A)}

write file-out tests
tests: copy ""

;; binary operator tests - in global context
foreach op test-binary-ops [
  foreach operand1 test-values [
    foreach operand2 test-values [
      ;; only write a test if REBOL produces a result
      if attempt [expected: do reduce [operand1 op operand2]][
        
        ;; don't write tests for certain ops with zero second operand
        if not all [
          operand2 = 0
          find test-no-zeroes op 
        ][
          expected: to-integer expected
          
          ;; convert REBOL's // operator to Red % operator
          nop: either op = first [//][#"%"][op]
          
          ;; test with literal values
          test-number: test-number + 1
          append tests join {  --test-- "integer-auto-} [test-number {"^(0A)}]
          append tests "  --assert "
          append tests reform [expected " = (" operand1 nop operand2 ")^(0A)"]
          
          ;; test with variables
          test-number: test-number + 1
          append tests join {  --test-- "integer-auto-} [test-number {"^(0A)}]
          append tests join "      i: " [operand1 "^(0A)"]
          append tests join "      j: " [operand2 "^(0A)"]
          append tests rejoin ["      k:  i " nop " j^(0A)"]
          append tests "  --assert "
          append tests reform [expected " = k ^(0A)"]
          
          ;; write tests to file
          write/append file-out tests
          tests: copy ""
        ]
      ]
      recycle
    ]
  ]
]

;; binary operator tests - inside a function

;; write function spec
append tests "  integer-auto-test-func: func [^(0A)"
;append tests "    return: [integer!]^(0A)"
append tests "      /local^(0A)"
append tests "      i [integer!]^(0A)"
append tests "      j [integer!]^(0A)"
append tests "      k [integer!]^(0A)"
append tests "    ][^(0A)"
write/append file-out tests
tests: copy ""

foreach op test-binary-ops [
  foreach operand1 test-values [
    foreach operand2 test-values [
      ;; only write a test if REBOL produces a result
      if attempt [expected: do reduce [operand1 op operand2]][
        
        ;; don't write tests for certain ops with zero second operand
        if not all [
          operand2 = 0
          find test-no-zeroes op 
        ][
          expected: to-integer expected
          
          ;; convert REBOL's // operator to Red/System's % operator
          nop: either op = first [//][#"%"][op]
         
          ;; test with variables inside the function
          test-number: test-number + 1
          append tests join {    --test-- "integer-auto-} [test-number {"^(0A)}]
          append tests join "      i: " [operand1 "^(0A)"]
          append tests join "      j: " [operand2 "^(0A)"]
          append tests rejoin ["      k:  i " nop " j^(0A)"]
          append tests "    --assert "
          append tests reform [expected " = k ^(0A)"]
          
          
          ;; write tests to file
          write/append file-out tests
          tests: copy ""
        ]
      ]
      recycle
    ]
  ]
]

;; write closing bracket and function call
append tests "  ]^(0a)"
append tests "integer-auto-test-func^(0a)"
write/append file-out tests
tests: copy ""


;; comparison tests
foreach op test-comparison-ops [
  foreach operand1 test-values [
    foreach operand2 test-comparison-values [
      ;; only write a test if REBOL produces a result
      if all [
        attempt [operand2: operand1 + operand2]
        none <> attempt [expected: do reduce [operand1 op operand2]]
      ][
        test-number: test-number + 1
        append tests join {  --test-- "integer-auto-} [test-number {"^(0A)}]
        append tests "  --assert "
        append tests reform [expected " = (" operand1 op operand2 ")^(0A)"]

        ;; write tests to file
        write/append file-out tests
        tests: copy ""
      ]
    ]
  ]
]


;; write file epilog
append tests "^(0A)===end-group===^(0A)^(0A)"
append tests {~~~end-file~~~^(0A)^(0A)}

write/append file-out tests
      
print ["Number of assertions generated" test-number]






